<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>mTouch Framework: Sliders and Wheels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">main</a>      </li>
      <li><a class="el" href="_framework_features.html">Features</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Sliders and Wheels </h1>  </div>
</div>
<div class="contents">
<p>The mTouch Framework has a special decoding module for sliders and wheels. It can support up to 10 sliders and up to 8 sensors per slider. The sensors used for the slider/wheel are configured as normal touch sensors. They will be scanned as a normal sensor and then, later, decoded as part of the slider.</p>
<h2><a class="anchor" id="featSlider-How"></a>
How It Works</h2>
<p>The slider/wheel decoding module is built on top of the normal decoding. It uses the delta readings of the most-pressed sensor and it's most-pressed neighbor to calculate the touched position. An example is shown below: </p>
<div align="center">
<img src="sliderInterpolation.jpg" alt="sliderInterpolation.jpg"/>
<p><strong>Slider Position Interpolation</strong></p></div>
<p> The interpolated position is calculated as follows: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Interpolated Press Position = (256 \cdot n) \pm \frac{Delta_{n}}{Delta_{n} + Delta_{n \pm 1}} \]" src="form_0.png"/>
</p>
<p>If <a class="el" href="group___configuration.html#gad9e2ca8d443a37df03d366c3cb08546e" title="If defined, slider output values will always fall between 0 and 255, regardless of the number of sens...">MTOUCH_SLIDER_SCALING_ENABLED</a> is defined, the scaled interpolated position is calculated: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Scaled Interpolated Press Position = \frac{InterpolatedPressPosition}{n} \]" src="form_1.png"/>
</p>
<p>In the equation, n is the most pressed sensor index. </p>
<div align="center">
<img src="sliderOutput.jpg" alt="sliderOutput.jpg"/>
<p><strong>Slider Output Values</strong></p></div>
 <h2><a class="anchor" id="featSlider-Config"></a>
Slider/Wheel Configuration</h2>
<ol>
<li>
Configure the slider/wheel sensors to be scanned as normal sensors in the <a class="el" href="m_touch__config_8h.html" title="Framework Configuration! Main configuration file for the mTouch Framework.">mTouch_config.h</a> file. Make sure every parameter is set appropriately, so that it can detect a normal touch. See the main configuration guide for more information on this step. </li>
<li>
Open the <a class="el" href="m_touch__config__slider_8h.html" title="Framework Configuration! Slider and Wheel Configuration Options.">mTouch_config_slider.h</a> file <ol type="a">
<li>
Set <a class="el" href="group___configuration.html#gae52f0e90f4bd2c45bab83d198f0f2748" title="Defines the number of sliders to be implemented.">MTOUCH_NUMBER_OF_SLIDERS</a> to the total number of sliders/wheels you want to implement. </li>
<li>
Set <a class="el" href="group___configuration.html#gadc491692c28eb41aa80923a8f32c59a7" title="Defines the maximum value that the latched slider output value is allowed to change based on one new ...">MTOUCH_SLIDER_STEP_SIZE</a>. A small step size will smooth your slider result but will limit its speed and response time. The default value (10) will generally give good results. </li>
<li>
Enable (recommended) or disable MTOUCH_SLIDER_SCALING_ENABLED based on your needs. If scaling is enabled, the output value will always fall between 0 and 255. If it is disabled, the maximum output value will be dependant on the InterpolatedPressPosition equation shown above. </li>
<li>
Configure each individual slider/wheel: <ul>
<li>
<p class="startli">For each slider, set MTOUCH_NUMBER_SLIDERx_SENSORS to the number of sensors that will be used to implement this particularly slider/wheel. (Where 'x' is the slider index.)</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define MTOUCH_NUMBER_SLIDER0_SENSORS  4</span>
</pre></div><p> Slider0 consists of 4 mTouch sensors</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For each sensor of each slider, set MTOUCH_SLIDERx_SENSORy to the MTOUCH_SENSOR index. (Where 'x' is the slider index and 'y' is the sensor index for that slider.)</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define MTOUCH_SLIDER0_SENSOR1  3</span>
</pre></div><p> Slider0's second sensor is MTOUCH_SENSOR3</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Define MTOUCH_SLIDERx_WHEEL_ENABLE if the slider is implemented as a wheel on the PCB. This will have it connect the first and last sensors of the slider in the decoding math, as well as implementing a speed and direction indication for use by the application.</p>
<p class="endli"></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><b>LIMITATION:</b> The framework is not currently able to implement both wheels and sliders in the same application. The framework is not currently able to support more than one wheel. So, the framework is able to support up to 10 sliders with 8 sensors per slider <b>OR</b> one wheel.</p>
<h2><a class="anchor" id="featSlider-Ex"></a>
Example</h2>
<p>Configure two sliders with scaling enabled. The first slider uses 4 sensors and the second slider uses 6.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// mTouch_config_slider.h</span>

<span class="preprocessor"> #define MTOUCH_NUMBER_OF_SLIDERS        2   </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER_STEP_SIZE         10        </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER_SCALING_ENABLED       // Slider values will be from 0 to 255</span>
<span class="preprocessor"></span>
 <span class="comment">// mTouch Slider0 Configuration </span>
<span class="preprocessor"> #define MTOUCH_NUMBER_SLIDER0_SENSORS   4   // &lt;-- Number of sensors that make up slider 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER0_SENSOR0          3   </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER0_SENSOR1          4   </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER0_SENSOR2          5  </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER0_SENSOR3          6   </span>
<span class="preprocessor"></span> <span class="comment">//#define MTOUCH_SLIDER0_WHEEL_ENABLE       // &#39;Wheel&#39; disabled</span>
    
 <span class="comment">// mTouch Slider1 Configuration </span>
<span class="preprocessor"> #define MTOUCH_NUMBER_SLIDER1_SENSORS   6   // &lt;-- Number of sensors that make up slider 1</span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR0          7   </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR1          8       </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR2          9   </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR3          10       </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR4          11  </span>
<span class="preprocessor"></span><span class="preprocessor"> #define MTOUCH_SLIDER1_SENSOR5          12       </span>
<span class="preprocessor"> //#define MTOUCH_SLIDER0_WHEEL_ENABLE       // &#39;Wheel&#39; disabled</span>
</pre></div><h2><a class="anchor" id="featSlider-Out"></a>
Slider/Wheel Output</h2>
<p>The framework provides one output for sliders (position) and three outputs for wheels (position, speed, direction). </p>
<ul>
<li>
The slider/wheel position output is stored in the mTouch_slider array. </li>
<li>
The wheel's extra outputs are stored in a struct called wheelStatus. It contains speed in wheelStatus.speed and direction in wheelStatus.direction. <ul>
<li>
The speed range is from 0 to 31, with 0 being no movement and 31 being the fastest. </li>
<li>
The direction has three states: 0x00 for no-scrolling, 0x01 for scrolling in the positive index direction, 0x02 for scrolling in the negative index direction. </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="featSlider-API"></a>
Slider/Wheel API</h2>
<p>The API for handling the slider and wheel outputs are: </p>
<ul>
<li>
mTouch_GetSlider(i) :: returns the value of slider/wheel i </li>
<li>
wheelStatus.direction :: stores the current direction of the wheel </li>
<li>
wheelStatus.speed :: stores the current speed of the wheel </li>
</ul>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Light a line of LEDs based on the slider output value</span>
 <span class="comment">// 8 LEDs, 9 total &quot;slider output values&quot; for this application. 0 (all off) to 8 (all on).</span>
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 28)  { LED0 = LED_ON; } <span class="keywordflow">else</span> { LED0 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 57)  { LED1 = LED_ON; } <span class="keywordflow">else</span> { LED1 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 85)  { LED2 = LED_ON; } <span class="keywordflow">else</span> { LED2 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 114) { LED3 = LED_ON; } <span class="keywordflow">else</span> { LED3 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 142) { LED4 = LED_ON; } <span class="keywordflow">else</span> { LED4 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 170) { LED5 = LED_ON; } <span class="keywordflow">else</span> { LED5 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 199) { LED6 = LED_ON; } <span class="keywordflow">else</span> { LED6 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= 227) { LED7 = LED_ON; } <span class="keywordflow">else</span> { LED7 = LED_OFF; }
</pre></div><div class="fragment"><pre class="fragment"> <span class="comment">// Same as above, but with slider scaling disabled.</span>
 <span class="comment">// 8 LEDs, 9 total &quot;slider output values&quot; for this application. 0 (all off) to 8 (all on).</span>
<span class="preprocessor"> #define MTOUCH_SLIDER0_MAX_VALUE     ((MTOUCH_NUMBER_SLIDER0_SENSORS - 1) * 256)</span>
<span class="preprocessor"></span> <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 1/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED0 = LED_ON; } <span class="keywordflow">else</span> { LED0 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 2/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED1 = LED_ON; } <span class="keywordflow">else</span> { LED1 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 3/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED2 = LED_ON; } <span class="keywordflow">else</span> { LED2 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 4/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED3 = LED_ON; } <span class="keywordflow">else</span> { LED3 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 5/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED4 = LED_ON; } <span class="keywordflow">else</span> { LED4 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 6/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED5 = LED_ON; } <span class="keywordflow">else</span> { LED5 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 7/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED6 = LED_ON; } <span class="keywordflow">else</span> { LED6 = LED_OFF; }
 <span class="keywordflow">if</span> (mTouch_GetSlider(0) &gt;= (uint16_t)( 8/9 * MTOUCH_SLIDER0_MAX_VALUE)) { LED7 = LED_ON; } <span class="keywordflow">else</span> { LED7 = LED_OFF; }
</pre></div><h2><a class="anchor" id="featSlider-FAQ"></a>
Frequently Asked Questions</h2>
<ul>
<li>
<b>Is it possible to make a slider using only one sensor? It could be a single long triangle that gets thinner/thicker as the finger moves along it.</b><br/>
<br/>
 No. <ul>
<li>
With only one sensor, there is no way to distinguish between a finger moving side-to-side on the slider and a finger moving up-and-down over the largest part of the slider. The shift magnitude in both cases will change from 0 to 255. </li>
<li>
If the slider's current value is 255 (max) and the user presses on position 0 of the slider (the thinnest part) how will the slider know to update its value? The finger's effect on the sensor will be minimal, so the shift will be close to 0. With a 2-channel slider, the shifts on the two sensors will be opposites. So we won't see a shift on the first sensor, but the second one will have a large shift. </li>
<li>
What if the slider's value is 255 when the user releases in the 'up' direction? How will the slider know that the user is going up instead of side-to-side? With a 2-channel slider, we compare the relationship between the two sensors to see if their ratio changes. Up-down press directions cause only small changes in the ratio while side-to-side directions cause large changes in the ratio. </li>
<li>
The only output value of a sensor is its magnitude, but the maximum magnitude will depend on the user of the application. A middle-aged man with large hands will cause a larger maximum shift than a 50 lb child. So the ratio between two sensors must be used to eliminate this difference. </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Regular capacitive buttons require only one sensors because we're looking for a step-response in the signal - the transition between pressed and released. We are not attempting to use the magnitude to further extrapolate information such as a position. </dd></dl>
</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>mTouch Framework v2.3 documentation by&#160;
<a href="http://www.microchip.com"> 
<img class="footer" src="../includes/mchp.jpeg" alt="Click here to visit our website at www.microchip.com"/></a></small></address> 
</body> 
</html> 
